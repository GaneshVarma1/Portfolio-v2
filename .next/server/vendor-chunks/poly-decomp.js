"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/poly-decomp";
exports.ids = ["vendor-chunks/poly-decomp"];
exports.modules = {

/***/ "(ssr)/./node_modules/poly-decomp/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/poly-decomp/src/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */ function lineInt(l1, l2, precision) {\n    precision = precision || 0;\n    var i = [\n        0,\n        0\n    ]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2 * b1;\n    if (!scalar_eq(det, 0, precision)) {\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */ function lineSegmentsIntersect(p1, p2, q1, q2) {\n    var dx = p2[0] - p1[0];\n    var dy = p2[1] - p1[1];\n    var da = q2[0] - q1[0];\n    var db = q2[1] - q1[1];\n    // segments are parallel\n    if (da * dy - db * dx === 0) {\n        return false;\n    }\n    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */ function triangleArea(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction isLeft(a, b, c) {\n    return triangleArea(a, b, c) > 0;\n}\nfunction isLeftOn(a, b, c) {\n    return triangleArea(a, b, c) >= 0;\n}\nfunction isRight(a, b, c) {\n    return triangleArea(a, b, c) < 0;\n}\nfunction isRightOn(a, b, c) {\n    return triangleArea(a, b, c) <= 0;\n}\nvar tmpPoint1 = [], tmpPoint2 = [];\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */ function collinear(a, b, c, thresholdAngle) {\n    if (!thresholdAngle) {\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1, bc = tmpPoint2;\n        ab[0] = b[0] - a[0];\n        ab[1] = b[1] - a[1];\n        bc[0] = c[0] - b[0];\n        bc[1] = c[1] - b[1];\n        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));\n        return angle < thresholdAngle;\n    }\n}\nfunction sqdist(a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */ function polygonAt(polygon, i) {\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */ function polygonClear(polygon) {\n    polygon.length = 0;\n}\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */ function polygonAppend(polygon, poly, from, to) {\n    for(var i = from; i < to; i++){\n        polygon.push(poly[i]);\n    }\n}\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */ function polygonMakeCCW(polygon) {\n    var br = 0, v = polygon;\n    // find bottom right point\n    for(var i = 1; i < polygon.length; ++i){\n        if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n            br = i;\n        }\n    }\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */ function polygonReverse(polygon) {\n    var tmp = [];\n    var N = polygon.length;\n    for(var i = 0; i !== N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i = 0; i !== N; i++){\n        polygon[i] = tmp[i];\n    }\n}\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */ function polygonIsReflex(polygon, i) {\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\nvar tmpLine1 = [], tmpLine2 = [];\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */ function polygonCanSee(polygon, a, b) {\n    var p, dist, l1 = tmpLine1, l2 = tmpLine2;\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for(var i = 0; i !== polygon.length; ++i){\n        if ((i + 1) % polygon.length === a || i === a) {\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1, l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */ function polygonCanSee2(polygon, a, b) {\n    // for each edge\n    for(var i = 0; i !== polygon.length; ++i){\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n            continue;\n        }\n        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */ function polygonCopy(polygon, i, j, targetPoly) {\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k = i; k <= j; k++){\n            p.push(polygon[k]);\n        }\n    } else {\n        // Insert vertices 0 to j\n        for(var k = 0; k <= j; k++){\n            p.push(polygon[k]);\n        }\n        // Insert vertices i to end\n        for(var k = i; k < polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n    return p;\n}\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */ function polygonGetCutEdges(polygon) {\n    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n    for(var i = 0; i < polygon.length; ++i){\n        if (polygonIsReflex(polygon, i)) {\n            for(var j = 0; j < polygon.length; ++j){\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n                    for(var k = 0; k < tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([\n                            polygonAt(polygon, i),\n                            polygonAt(polygon, j)\n                        ]);\n                    }\n                }\n            }\n        }\n    }\n    return min;\n}\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */ function polygonDecomp(polygon) {\n    var edges = polygonGetCutEdges(polygon);\n    if (edges.length > 0) {\n        return polygonSlice(polygon, edges);\n    } else {\n        return [\n            polygon\n        ];\n    }\n}\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */ function polygonSlice(polygon, cutEdges) {\n    if (cutEdges.length === 0) {\n        return [\n            polygon\n        ];\n    }\n    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n        var polys = [\n            polygon\n        ];\n        for(var i = 0; i < cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j = 0; j < polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if (result) {\n                    // Found poly! Cut and quit\n                    polys.splice(j, 1);\n                    polys.push(result[0], result[1]);\n                    break;\n                }\n            }\n        }\n        return polys;\n    } else {\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n        if (i !== -1 && j !== -1) {\n            return [\n                polygonCopy(polygon, i, j),\n                polygonCopy(polygon, j, i)\n            ];\n        } else {\n            return false;\n        }\n    }\n}\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */ function polygonIsSimple(polygon) {\n    var path = polygon, i;\n    // Check\n    for(i = 0; i < path.length - 1; i++){\n        for(var j = 0; j < i - 1; j++){\n            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n                return false;\n            }\n        }\n    }\n    // Check the segment between the last and the first point to all others\n    for(i = 1; i < path.length - 2; i++){\n        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n    delta = delta || 0;\n    var a1 = p2[1] - p1[1];\n    var b1 = p1[0] - p2[0];\n    var c1 = a1 * p1[0] + b1 * p1[1];\n    var a2 = q2[1] - q1[1];\n    var b2 = q1[0] - q2[0];\n    var c2 = a2 * q1[0] + b2 * q1[1];\n    var det = a1 * b2 - a2 * b1;\n    if (!scalar_eq(det, 0, delta)) {\n        return [\n            (b2 * c1 - b1 * c2) / det,\n            (a1 * c2 - a2 * c1) / det\n        ];\n    } else {\n        return [\n            0,\n            0\n        ];\n    }\n}\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */ function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof result !== \"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n    var upperInt = [\n        0,\n        0\n    ], lowerInt = [\n        0,\n        0\n    ], p = [\n        0,\n        0\n    ]; // Points\n    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars\n    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers\n    var lowerPoly = [], upperPoly = []; // polygons\n    var poly = polygon, v = polygon;\n    if (v.length < 3) {\n        return result;\n    }\n    level++;\n    if (level > maxlevel) {\n        console.warn(\"quickDecomp: max level (\" + maxlevel + \") reached.\");\n        return result;\n    }\n    for(var i = 0; i < polygon.length; ++i){\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n            for(var j = 0; j < polygon.length; ++j){\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) {\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0) {\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly, 0, i + 1);\n                } else {\n                    if (i !== 0) {\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly, i, poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n                if (upperIndex < lowerIndex) {\n                    return result;\n                }\n                for(var j = lowerIndex; j <= upperIndex; ++j){\n                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n                    if (closestIndex !== 0) {\n                        polygonAppend(upperPoly, poly, closestIndex, v.length);\n                    }\n                    polygonAppend(upperPoly, poly, 0, i + 1);\n                } else {\n                    if (i !== 0) {\n                        polygonAppend(lowerPoly, poly, i, v.length);\n                    }\n                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n                    polygonAppend(upperPoly, poly, closestIndex, i + 1);\n                }\n            }\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n            } else {\n                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n            }\n            return result;\n        }\n    }\n    result.push(polygon);\n    return result;\n}\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */ function polygonRemoveCollinearPoints(polygon, precision) {\n    var num = 0;\n    for(var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i){\n        if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n            // Remove the middle point\n            polygon.splice(i % polygon.length, 1);\n            num++;\n        }\n    }\n    return num;\n}\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */ function polygonRemoveDuplicatePoints(polygon, precision) {\n    for(var i = polygon.length - 1; i >= 1; --i){\n        var pi = polygon[i];\n        for(var j = i - 1; j >= 0; --j){\n            if (points_eq(pi, polygon[j], precision)) {\n                polygon.splice(i, 1);\n                continue;\n            }\n        }\n    }\n}\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */ function scalar_eq(a, b, precision) {\n    precision = precision || 0;\n    return Math.abs(a - b) <= precision;\n}\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */ function points_eq(a, b, precision) {\n    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2JDLFFBQVFDO0lBQ1JDLGFBQWFDO0lBQ2JDLFVBQVVDO0lBQ1ZDLHVCQUF1QkM7SUFDdkJDLHVCQUF1QkM7SUFDdkJDLFNBQVNDO0FBQ2I7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLFFBQVFDLEVBQUUsRUFBQ0MsRUFBRSxFQUFDQyxTQUFTO0lBQzVCQSxZQUFZQSxhQUFhO0lBQ3pCLElBQUlDLElBQUk7UUFBQztRQUFFO0tBQUUsRUFBRSxRQUFRO0lBQ3ZCLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLEtBQUssVUFBVTtJQUMzQ04sS0FBS0osRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUN4QkssS0FBS0wsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUN4Qk0sS0FBS0YsS0FBS0osRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdLLEtBQUtMLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNsQ08sS0FBS04sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUN4Qk8sS0FBS1AsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUN4QlEsS0FBS0YsS0FBS04sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdPLEtBQUtQLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNsQ1MsTUFBTU4sS0FBS0ksS0FBS0QsS0FBR0Y7SUFDbkIsSUFBSSxDQUFDTSxVQUFVRCxLQUFLLEdBQUdSLFlBQVk7UUFDL0JDLENBQUMsQ0FBQyxFQUFFLEdBQUcs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QUFDdkIsU0FBUztJQUM1QkEsWUFBWUEsYUFBYTtJQUN6QixPQUFPcUMsS0FBS3dFLEdBQUcsQ0FBQ3ZGLElBQUVDLE1BQU12QjtBQUM1QjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBUzRHLFVBQVV0RixDQUFDLEVBQUNDLENBQUMsRUFBQ3ZCLFNBQVM7SUFDNUIsT0FBT1MsVUFBVWEsQ0FBQyxDQUFDLEVBQUUsRUFBQ0MsQ0FBQyxDQUFDLEVBQUUsRUFBQ3ZCLGNBQWNTLFVBQVVhLENBQUMsQ0FBQyxFQUFFLEVBQUNDLENBQUMsQ0FBQyxFQUFFLEVBQUN2QjtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby12Mi8uL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvaW5kZXguanM/N2UyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWNvbXA6IHBvbHlnb25EZWNvbXAsXG4gICAgcXVpY2tEZWNvbXA6IHBvbHlnb25RdWlja0RlY29tcCxcbiAgICBpc1NpbXBsZTogcG9seWdvbklzU2ltcGxlLFxuICAgIHJlbW92ZUNvbGxpbmVhclBvaW50czogcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyxcbiAgICByZW1vdmVEdXBsaWNhdGVQb2ludHM6IHBvbHlnb25SZW1vdmVEdXBsaWNhdGVQb2ludHMsXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5mdW5jdGlvbiBsaW5lSW50KGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKXtcblx0dmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGRhID0gcTJbMF0gLSBxMVswXTtcblx0dmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuXHQvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcblx0aWYoKGRhKmR5IC0gZGIqZHgpID09PSAwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XG5cdHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcblxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59XG5cbmZ1bmN0aW9uIGlzTGVmdChhLGIsYyl7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLGIsYykgPiAwO1xufVxuXG5mdW5jdGlvbiBpc0xlZnRPbihhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xufVxuXG5mdW5jdGlvbiBpc1JpZ2h0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XG59XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxZGlzdChhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSl7XG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNsZWFyKHBvbHlnb24pe1xuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFwcGVuZChwb2x5Z29uLCBwb2x5LCBmcm9tLCB0byl7XG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICB2YXIgTiA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdG1wLnB1c2gocG9seWdvbi5wb3AoKSk7XG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblx0XHRwb2x5Z29uW2ldID0gdG1wW2ldO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSl7XG4gICAgcmV0dXJuIGlzUmlnaHQocG9seWdvbkF0KHBvbHlnb24sIGkgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpKTtcbn1cblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLGIpIHtcbiAgICB2YXIgcCwgZGlzdCwgbDE9dG1wTGluZTEsIGwyPXRtcExpbmUyO1xuXG4gICAgaWYgKGlzTGVmdE9uKHBvbHlnb25BdChwb2x5Z29uLCBhICsgMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHlnb24sIGEgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHBvbHlnb24ubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxuICAgICAgICBpZiAoKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpeyAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSkpKSB7IC8vIGlmIGRpYWcgaW50ZXJzZWN0cyBhbiBlZGdlXG4gICAgICAgICAgICBsMVswXSA9IHBvbHlnb25BdChwb2x5Z29uLCBhKTtcbiAgICAgICAgICAgIGwxWzFdID0gcG9seWdvbkF0KHBvbHlnb24sIGIpO1xuICAgICAgICAgICAgbDJbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSk7XG4gICAgICAgICAgICBsMlsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSk7XG4gICAgICAgICAgICBwID0gbGluZUludChsMSxsMik7XG4gICAgICAgICAgICBpZiAoc3FkaXN0KHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcCkgPCBkaXN0KSB7IC8vIGlmIGVkZ2UgaXMgYmxvY2tpbmcgdmlzaWJpbGl0eSB0byBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlcnRpY2VzIGluIHRoZSBwb2x5Z29uIGNhbiBzZWUgZWFjaCBvdGhlclxuICogQG1ldGhvZCBjYW5TZWUyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNhblNlZTIocG9seWdvbiwgYSxiKSB7XG4gICAgLy8gZm9yIGVhY2ggZWRnZVxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xuICAgICAgICBpZiAoaSA9PT0gYSB8fCBpID09PSBiIHx8IChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCAoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGIpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGxpbmVTZWdtZW50c0ludGVyc2VjdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSsxKSkgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSBwb2x5Z29uIGZyb20gdmVydGV4IGkgdG8gdmVydGV4IGouXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxuICogQHJldHVybiB7UG9seWdvbn0gICAgICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBjb3B5LlxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLGosdGFyZ2V0UG9seSl7XG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5IHx8IFtdO1xuICAgIHBvbHlnb25DbGVhcihwKTtcbiAgICBpZiAoaSA8IGopIHtcbiAgICAgICAgLy8gSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBmcm9tIGkgdG8galxuICAgICAgICBmb3IodmFyIGs9aTsgazw9ajsgaysrKXtcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgMCB0byBqXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1qOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIGkgdG8gZW5kXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPHBvbHlnb24ubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIGNvbnZleCBwaWVjZXMuIFJldHVybnMgYSBsaXN0IG9mIGVkZ2VzIFtbcDEscDJdLFtwMixwM10sLi4uXSB0aGF0IGN1dHMgdGhlIHBvbHlnb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKSB7XG4gICAgdmFyIG1pbj1bXSwgdG1wMT1bXSwgdG1wMj1bXSwgdG1wUG9seSA9IFtdO1xuICAgIHZhciBuRGlhZ3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uQ2FuU2VlKHBvbHlnb24sIGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xuICAgICAgICAgICAgICAgICAgICB0bXAyID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb25Db3B5KHBvbHlnb24sIGosIGksIHRtcFBvbHkpKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDEucHVzaCh0bXAyW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2goW3BvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGopXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxuICogQG1ldGhvZCBkZWNvbXBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25EZWNvbXAocG9seWdvbil7XG4gICAgdmFyIGVkZ2VzID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pO1xuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApe1xuICAgICAgICByZXR1cm4gcG9seWdvblNsaWNlKHBvbHlnb24sIGVkZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTbGljZXMgdGhlIHBvbHlnb24gZ2l2ZW4gb25lIG9yIG1vcmUgY3V0IGVkZ2VzLiBJZiBnaXZlbiBvbmUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHdvIHBvbHlnb25zIChmYWxzZSBvbiBmYWlsdXJlKS4gSWYgbWFueSwgYW4gYXJyYXkgb2YgcG9seWdvbnMuXG4gKiBAbWV0aG9kIHNsaWNlXG4gKiBAcGFyYW0ge0FycmF5fSBjdXRFZGdlcyBBIGxpc3Qgb2YgZWRnZXMsIGFzIHJldHVybmVkIGJ5IC5nZXRDdXRFZGdlcygpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvblNsaWNlKHBvbHlnb24sIGN1dEVkZ2VzKXtcbiAgICBpZihjdXRFZGdlcy5sZW5ndGggPT09IDApe1xuXHRcdHJldHVybiBbcG9seWdvbl07XG4gICAgfVxuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT09MiAmJiBjdXRFZGdlc1swXVswXSBpbnN0YW5jZW9mIEFycmF5KXtcblxuICAgICAgICB2YXIgcG9seXMgPSBbcG9seWdvbl07XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlc1tpXTtcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5Z29uU2xpY2UocG9seSwgY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSBwb2x5Z29uLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT09IC0xICYmIGogIT09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbcG9seWdvbkNvcHkocG9seWdvbiwgaSxqKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkNvcHkocG9seWdvbiwgaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cbiAqIEBtZXRob2QgaXNTaW1wbGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXRoIEFuIGFycmF5IG9mIHZlcnRpY2VzIGUuZy4gW1swLDBdLFswLDFdLC4uLl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAdG9kbyBTaG91bGQgaXQgY2hlY2sgYWxsIHNlZ21lbnRzIHdpdGggYWxsIG90aGVycz9cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pe1xuICAgIHZhciBwYXRoID0gcG9seWdvbiwgaTtcbiAgICAvLyBDaGVja1xuICAgIGZvcihpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aS0xOyBqKyspe1xuICAgICAgICAgICAgaWYobGluZVNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKGk9MTsgaTxwYXRoLmxlbmd0aC0yOyBpKyspe1xuICAgICAgICBpZihsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aFtpXSwgcGF0aFtpKzFdICkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG5cdGRlbHRhID0gZGVsdGEgfHwgMDtcblx0dmFyIGExID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGIxID0gcDFbMF0gLSBwMlswXTtcblx0dmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xuXHR2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuXHR2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xuXHR2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XG5cdHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cblx0aWYoIXNjYWxhcl9lcShkZXQsMCxkZWx0YSkpe1xuXHRcdHJldHVybiBbKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQsICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0XTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gWzAsMF07XG4gICAgfVxufVxuXG4vKipcbiAqIFF1aWNrbHkgZGVjb21wb3NlIHRoZSBQb2x5Z29uIGludG8gY29udmV4IHN1Yi1wb2x5Z29ucy5cbiAqIEBtZXRob2QgcXVpY2tEZWNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqIEBwYXJhbSAge0FycmF5fSBbcmVmbGV4VmVydGljZXNdXG4gKiBAcGFyYW0gIHtBcnJheX0gW3N0ZWluZXJQb2ludHNdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWx0YV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21heGxldmVsXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGV2ZWxdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvblF1aWNrRGVjb21wKHBvbHlnb24sIHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKXtcbiAgICBtYXhsZXZlbCA9IG1heGxldmVsIHx8IDEwMDtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAyNTtcbiAgICByZXN1bHQgPSB0eXBlb2YocmVzdWx0KSE9PVwidW5kZWZpbmVkXCIgPyByZXN1bHQgOiBbXTtcbiAgICByZWZsZXhWZXJ0aWNlcyA9IHJlZmxleFZlcnRpY2VzIHx8IFtdO1xuICAgIHN0ZWluZXJQb2ludHMgPSBzdGVpbmVyUG9pbnRzIHx8IFtdO1xuXG4gICAgdmFyIHVwcGVySW50PVswLDBdLCBsb3dlckludD1bMCwwXSwgcD1bMCwwXTsgLy8gUG9pbnRzXG4gICAgdmFyIHVwcGVyRGlzdD0wLCBsb3dlckRpc3Q9MCwgZD0wLCBjbG9zZXN0RGlzdD0wOyAvLyBzY2FsYXJzXG4gICAgdmFyIHVwcGVySW5kZXg9MCwgbG93ZXJJbmRleD0wLCBjbG9zZXN0SW5kZXg9MDsgLy8gSW50ZWdlcnNcbiAgICB2YXIgbG93ZXJQb2x5PVtdLCB1cHBlclBvbHk9W107IC8vIHBvbHlnb25zXG4gICAgdmFyIHBvbHkgPSBwb2x5Z29uLFxuICAgICAgICB2ID0gcG9seWdvbjtcblxuICAgIGlmKHYubGVuZ3RoIDwgMyl7XG5cdFx0cmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXZlbCsrO1xuICAgIGlmKGxldmVsID4gbWF4bGV2ZWwpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJxdWlja0RlY29tcDogbWF4IGxldmVsIChcIittYXhsZXZlbCtcIikgcmVhY2hlZC5cIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seVtpXSk7XG4gICAgICAgICAgICB1cHBlckRpc3QgPSBsb3dlckRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5W2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PT0gKHVwcGVySW5kZXggKyAxKSAlIHBvbHlnb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrcG9seWdvbi5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksbG93ZXJJbmRleCxwb2x5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGkscG9seS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxsb3dlckluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAyOiBWZXJ0ZXgoXCIraStcIiksIGNsb3Nlc3RJbmRleChcIitjbG9zZXN0SW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrcG9seWdvbi5sZW5ndGgrXCIpXFxuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPiB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggKz0gcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgICAgIGlmKHVwcGVySW5kZXggPCBsb3dlckluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbG93ZXJJbmRleDsgaiA8PSB1cHBlckluZGV4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0ICYmIHBvbHlnb25DYW5TZWUyKHBvbHksIGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGksY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGNsb3Nlc3RJbmRleCx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGksdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcbiAgICAgICAgICAgIGlmIChsb3dlclBvbHkubGVuZ3RoIDwgdXBwZXJQb2x5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcChsb3dlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG4gKiBAbWV0aG9kIHJlbW92ZUNvbGxpbmVhclBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXSBUaGUgdGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGVkZ2VzIGFyZSBjb2xsaW5lYXIuIFVzZSB6ZXJvIGZvciBmaW5lc3QgcHJlY2lzaW9uLlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlQ29sbGluZWFyUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbil7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yKHZhciBpPXBvbHlnb24ubGVuZ3RoLTE7IHBvbHlnb24ubGVuZ3RoPjMgJiYgaT49MDsgLS1pKXtcbiAgICAgICAgaWYoY29sbGluZWFyKHBvbHlnb25BdChwb2x5Z29uLCBpLTEpLHBvbHlnb25BdChwb2x5Z29uLCBpKSxwb2x5Z29uQXQocG9seWdvbiwgaSsxKSxwcmVjaXNpb24pKXtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICBwb2x5Z29uLnNwbGljZShpJXBvbHlnb24ubGVuZ3RoLDEpO1xuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cbiAqIEBtZXRob2QgcmVtb3ZlRHVwbGljYXRlUG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gcG9pbnRzIGFyZSB0aGUgc2FtZS4gVXNlIHplcm8gZm9yIGJlc3QgcHJlY2lzaW9uLlxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbil7XG4gICAgZm9yKHZhciBpPXBvbHlnb24ubGVuZ3RoLTE7IGk+PTE7IC0taSl7XG4gICAgICAgIHZhciBwaSA9IHBvbHlnb25baV07XG4gICAgICAgIGZvcih2YXIgaj1pLTE7IGo+PTA7IC0tail7XG4gICAgICAgICAgICBpZihwb2ludHNfZXEocGksIHBvbHlnb25bal0sIHByZWNpc2lvbikpe1xuICAgICAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGksMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDw9IHByZWNpc2lvbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBwb2ludHNfZXFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9pbnRzX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHJldHVybiBzY2FsYXJfZXEoYVswXSxiWzBdLHByZWNpc2lvbikgJiYgc2NhbGFyX2VxKGFbMV0sYlsxXSxwcmVjaXNpb24pO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJkZWNvbXAiLCJwb2x5Z29uRGVjb21wIiwicXVpY2tEZWNvbXAiLCJwb2x5Z29uUXVpY2tEZWNvbXAiLCJpc1NpbXBsZSIsInBvbHlnb25Jc1NpbXBsZSIsInJlbW92ZUNvbGxpbmVhclBvaW50cyIsInBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMiLCJyZW1vdmVEdXBsaWNhdGVQb2ludHMiLCJwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzIiwibWFrZUNDVyIsInBvbHlnb25NYWtlQ0NXIiwibGluZUludCIsImwxIiwibDIiLCJwcmVjaXNpb24iLCJpIiwiYTEiLCJiMSIsImMxIiwiYTIiLCJiMiIsImMyIiwiZGV0Iiwic2NhbGFyX2VxIiwibGluZVNlZ21lbnRzSW50ZXJzZWN0IiwicDEiLCJwMiIsInExIiwicTIiLCJkeCIsImR5IiwiZGEiLCJkYiIsInMiLCJ0IiwidHJpYW5nbGVBcmVhIiwiYSIsImIiLCJjIiwiaXNMZWZ0IiwiaXNMZWZ0T24iLCJpc1JpZ2h0IiwiaXNSaWdodE9uIiwidG1wUG9pbnQxIiwidG1wUG9pbnQyIiwiY29sbGluZWFyIiwidGhyZXNob2xkQW5nbGUiLCJhYiIsImJjIiwiZG90IiwibWFnQSIsIk1hdGgiLCJzcXJ0IiwibWFnQiIsImFuZ2xlIiwiYWNvcyIsInNxZGlzdCIsInBvbHlnb25BdCIsInBvbHlnb24iLCJsZW5ndGgiLCJwb2x5Z29uQ2xlYXIiLCJwb2x5Z29uQXBwZW5kIiwicG9seSIsImZyb20iLCJ0byIsInB1c2giLCJiciIsInYiLCJwb2x5Z29uUmV2ZXJzZSIsInRtcCIsIk4iLCJwb3AiLCJwb2x5Z29uSXNSZWZsZXgiLCJ0bXBMaW5lMSIsInRtcExpbmUyIiwicG9seWdvbkNhblNlZSIsInAiLCJkaXN0IiwicG9seWdvbkNhblNlZTIiLCJwb2x5Z29uQ29weSIsImoiLCJ0YXJnZXRQb2x5IiwiayIsInBvbHlnb25HZXRDdXRFZGdlcyIsIm1pbiIsInRtcDEiLCJ0bXAyIiwidG1wUG9seSIsIm5EaWFncyIsIk51bWJlciIsIk1BWF9WQUxVRSIsImVkZ2VzIiwicG9seWdvblNsaWNlIiwiY3V0RWRnZXMiLCJBcnJheSIsInBvbHlzIiwiY3V0RWRnZSIsInJlc3VsdCIsInNwbGljZSIsImluZGV4T2YiLCJwYXRoIiwiZ2V0SW50ZXJzZWN0aW9uUG9pbnQiLCJkZWx0YSIsInJlZmxleFZlcnRpY2VzIiwic3RlaW5lclBvaW50cyIsIm1heGxldmVsIiwibGV2ZWwiLCJ1cHBlckludCIsImxvd2VySW50IiwidXBwZXJEaXN0IiwibG93ZXJEaXN0IiwiZCIsImNsb3Nlc3REaXN0IiwidXBwZXJJbmRleCIsImxvd2VySW5kZXgiLCJjbG9zZXN0SW5kZXgiLCJsb3dlclBvbHkiLCJ1cHBlclBvbHkiLCJjb25zb2xlIiwid2FybiIsIm51bSIsInBpIiwicG9pbnRzX2VxIiwiYWJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/poly-decomp/src/index.js\n");

/***/ })

};
;